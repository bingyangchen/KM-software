{
	"nodes":[
		{"id":"3f54d2c97748bacd","type":"text","text":"因為 `insert` 的 time complexity 還是 $O(n)$，所以整體的 time complexity 還是 $O(n^2)$","x":2192,"y":1054,"width":318,"height":135},
		{"id":"a77b2f8f083d24cb","type":"text","text":"- Step1: 建立一個空的 sorted array\n- Step2: 從 original array 中拿出（移除）第一個元素（或最後一個），找到 sorted array 中適合放入此元素的位置並將其放入\n- Step3: 重複 Step2 直到 original array 沒有東西為止","x":2405,"y":39,"width":460,"height":242},
		{"id":"39c0aff4325accff","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":2471,"y":638,"width":329,"height":119},
		{"id":"3ff105201d33ae16","type":"text","text":"#### Insertion Sort","x":2529,"y":424,"width":214,"height":61},
		{"id":"0f214ef64bddf7d3","type":"text","text":"```Python\ndef insertion_sort(nums: list[int]) -> list[int]:\n    result = []\n    while nums:\n        num = nums.pop()\n\n        # linear search\n        idx = 0\n        while idx < len(result):\n            if result[idx] >= num:\n                break\n            idx += 1\n\n        result.insert(idx, num)\n    return result\n```","x":2924,"y":246,"width":533,"height":418},
		{"id":"c28e42e401df65f5","type":"text","text":"```Python\ndef insertion_sort_with_binary_search(nums: list[int]) -> list[int]:\n    result = []\n    while nums:\n        num = nums.pop()\n\n        # binary search\n        l, r = 0, len(result) - 1\n        while l < r:\n            m = (l+r) // 2\n            if result[m] > num:\n                r = m\n            elif result[m] < num:\n                l = m + 1\n            else:\n                l = r = m\n        if len(result) > l and result[l] < num:\n            result.insert(l + 1, num)\n        else:\n            result.insert(l, num)\n    return result\n```","x":926,"y":609,"width":703,"height":552},
		{"id":"6c4680898ff60c73","type":"text","text":"本來 insertion sort 在將元素放進 sorted array 時，是用 linear search 找適合的位置，但其實這部分可以用 binary search 來加速","x":1714,"y":571,"width":420,"height":135},
		{"id":"98a1ec235945e259","type":"text","text":"直接把 original array 的前端當作 sorted array，找新元素適合的位置時，從 sorted array 的尾端開始找","x":1757,"y":-170,"width":335,"height":135},
		{"id":"fcd7d8a4440fecdc","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":1760,"y":1062,"width":329,"height":119},
		{"id":"2d6564c43ec63a03","type":"text","text":"#### Insertion Sort with Binary Search","x":1789,"y":833,"width":270,"height":103},
		{"id":"7910801f404a3a19","type":"text","text":"```Python\ndef in_place_insertion_sort(nums: list[int]) -> list[int]:\n    for i in range(1, len(nums)):\n        for j in range(i - 1, -1, -1):\n            k = j + 1\n            if nums[k] < nums[j]:\n                nums[k], nums[j] = nums[j], nums[k]\n            else:\n                break\n    return nums\n```","x":1014,"y":-15,"width":615,"height":307},
		{"id":"93285d355c4a4aec","type":"text","text":"#### In-Place Insertion Sort","x":1767,"y":106,"width":314,"height":65},
		{"id":"e69ec252f26c7f17","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":1760,"y":323,"width":329,"height":119},
		{"id":"238fb2e50f9313f9","type":"text","text":"- Step1: 比較 original array 中的第一個元素與第二個元素的大小，如果第一個元素比較大就將他們兩個的位置對調。以相同的方法比較第二個元素與第三個元素、第三個元素與第四個元素 ...... 直到比完倒數第二個元素與最後一個元素為止。比完後，original array 的最後一個元素一定會是整個 array 中最大的數字，這樣就排好了一個\n- Step2: 重複 Step1（但這次不用再管最後一個元素）就可以將第二大的元素放到倒數第二個位置。一直重複，每次都可以少看一個尾端的元素，直到整個 array 排完","x":-482,"y":124,"width":498,"height":350},
		{"id":"21546c66fbb84ba8","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":-401,"y":889,"width":329,"height":119},
		{"id":"0436ceea87da2e3e","type":"text","text":"#### Bubble Sort","x":-330,"y":684,"width":187,"height":58},
		{"id":"104c1cae4f4f3475","type":"text","text":"```Python\ndef bubble_sort(nums: list[int]) -> list[int]:\n    sorted_head_idx = len(nums)\n    while sorted_head_idx != 0:\n        next_sorted_head_idx = 0\n        for i in range(sorted_head_idx - 1):\n            j = i + 1\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                next_sorted_head_idx = j\n        sorted_head_idx = next_sorted_head_idx\n    return nums\n```","x":70,"y":538,"width":556,"height":351},
		{"id":"f6ec54fcdef157a5","type":"text","text":"因為每一輪都會找到 unsorted part 中最大的元素並將其放到 unsorted part 的最底部（成為 sorted part），所以又叫做 **sink sort**","x":159,"y":124,"width":335,"height":171},
		{"id":"540d7c093a4cbe68","type":"text","text":"Bubble sort 天生就是 in-place 的演算法","x":159,"y":374,"width":378,"height":64},
		{"id":"c05cbd6ca115a73f","type":"text","text":"```Python\ndef selection_sort(nums: list[int]) -> list[int]:\n    result = []\n    while nums:\n        min_ = min(nums)\n        nums.remove(min_)\n        result.append(min_)\n    return result\n```","x":-1358,"y":441,"width":533,"height":260},
		{"id":"b239c4f621252170","type":"text","text":"#### Selection Sort","x":-1694,"y":540,"width":212,"height":61},
		{"id":"73ff9bbfea7ce88b","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":-1752,"y":754,"width":329,"height":119},
		{"id":"b571365cfbc44810","type":"text","text":"- Step1: 建立一個空的 sorted array\n- Step2: 找到並拿出（移除）original array 中最小的元素，然後將該元素放入 sorted array 的末端\n- Step3: 重複 Step2 直到 original array 沒有東西為止","x":-1818,"y":192,"width":460,"height":206},
		{"id":"b099a8abcb8a817a","type":"text","text":"```Python\ndef bst_sort(nums: list[int]) -> list[int]:\n    class Node:\n        def __init__(self, val: int) -> None:\n            self.val = val\n            self.left: Node | None = None\n            self.right: Node | None = None\n\n    # build BST\n    root = Node(nums.pop())\n    for num in nums:\n        temp = root\n        while temp:\n            if num < temp.val and temp.left:\n                temp = temp.left\n            elif num >= temp.val and temp.right:\n                temp = temp.right\n            else:\n                break\n        if num < temp.val:\n            temp.left = Node(num)\n        else:\n            temp.right = Node(num)\n\n    result = []\n\n    def in_order_traverse(node: Node | None) -> None:\n        if node is None:\n            return\n        in_order_traverse(node.left)\n        result.append(node.val)\n        in_order_traverse(node.right)\n\n    in_order_traverse(root)\n    return result\n```","x":1699,"y":1593,"width":570,"height":865},
		{"id":"49fabe8895595128","type":"text","text":"- Step1: 將 original array 中的元素逐一放入一個 BST (binary-search tree) 中\n- Step2: 使用 in-order traversal 的方式遍歷整棵 BST 即得到 sorted array","x":1202,"y":1695,"width":355,"height":190},
		{"id":"9ee85fee782dd6ce","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":1215,"y":2194,"width":331,"height":119},
		{"id":"30eca70b868ae566","type":"text","text":"```Python\nimport heapq\n\ndef heap_sort(nums: list[int]) -> list[int]:\n    heapq.heapify(nums)\n    return [heapq.heappop(nums) for _ in range(len(nums))]\n```","x":1,"y":1935,"width":612,"height":205},
		{"id":"97681c6bb43c0713","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":-417,"y":2203,"width":331,"height":119},
		{"id":"4e54838da237b145","type":"text","text":"- Step1: 將 original array 中的元素逐一放進一個 min heap 中\n- Step2: 持續 pop min heap 的 root，直到 min heap 沒有元素為止","x":-421,"y":1695,"width":339,"height":190},
		{"id":"0eafa24b413ce2b2","type":"text","text":"#### Heap Sort","x":-335,"y":2010,"width":167,"height":55},
		{"id":"8a8df549279f0ee7","type":"text","text":"[[從 Binary Search 到 B+ Tree#BST (Binary Search Tree)|Binary Search Tree]]","x":927,"y":1996,"width":214,"height":60},
		{"id":"2b54e5495199d551","type":"file","file":"Data Structures & Algorithms/Heap.md","x":-1152,"y":1838,"width":649,"height":400},
		{"id":"50c261911d82ee44","type":"text","text":"Python 的 `sorted` 所使用的演算法就是 tim sort","x":-1494,"y":5033,"width":253,"height":100},
		{"id":"d69a7946c4b50c6b","type":"text","text":"原則上使用 merge sort，但當 array 被分割得「夠小」時，改用 in-place insertion sort","x":-1197,"y":4811,"width":292,"height":135},
		{"id":"911a07c2189041e8","type":"text","text":"```Python\ndef tim_sort(nums: list[int]) -> list[int]:\n    def in_place_insertion_sort(nums: list[int], start: int, end: int) -> None:\n        len_ = end - start + 1\n        for i in range(1, len_):\n            for j in range(start + i - 1, start - 1, -1):\n                k = j + 1\n                if nums[k] < nums[j]:\n                    nums[k], nums[j] = nums[j], nums[k]\n                else:\n                    break\n\n    def in_place_merge_sorted_lists(\n        nums: list[int], start: int, mid: int, end: int\n    ) -> None:\n        if start == mid or mid >= end:\n            return\n        left, right = nums[start : mid + 1], nums[mid + 1 : end + 1]\n        i, j, k = 0, 0, start\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n    run = 32\n    for i in range(0, len(nums), run):\n        in_place_insertion_sort(nums, i, min(i + run - 1, len(nums) - 1))\n    while run < len(nums):\n        for i in range(0, len(nums), 2 * run):\n            in_place_merge_sorted_lists(\n                nums,\n                i,\n                min(i + run - 1, len(nums) - 1),\n                min(i + 2 * run - 1, len(nums) - 1),\n            )\n        run *= 2\n    return nums\n```","x":-779,"y":4494,"width":806,"height":1177},
		{"id":"5ec23a0b444df1b0","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":-1221,"y":5234,"width":331,"height":119},
		{"id":"d10520631afaf9e9","type":"text","text":"只能排序數字或是有數字編號的東西","x":417,"y":5022,"width":196,"height":95},
		{"id":"5c7057e4ced9f40a","type":"text","text":"- Step1: 走訪 original array 一遍，由小到大紀錄每個數字出現幾次\n- Step2: 建立一個空的 sorted array，把 Step1 紀錄的數字由小到大填入每個數字填入 n 次，n 為記錄到該數字的出現次數","x":691,"y":4698,"width":381,"height":226},
		{"id":"b8a89c7ad719f60e","type":"text","text":"\n- Time complexity: $O(n + m)$\n- Auxiliary-Space Complexity: $O(n + m)$","x":699,"y":5206,"width":366,"height":119},
		{"id":"d860979a939c0b8e","type":"text","text":"m 為 original array 中最大數字與最小數字的差","x":757,"y":5417,"width":250,"height":100},
		{"id":"69ced796d4531c1b","type":"text","text":"#### Counting Sort","x":776,"y":5037,"width":211,"height":61},
		{"id":"da90a71b1cefabd2","type":"text","text":"```Python\ndef counting_sort(nums: list[int]) -> list[int]:\n    counts = [0] * (max(nums) +1)\n    for num in nums:\n        counts[num] += 1\n    result = []\n    for i in range(len(counts)):\n        for _ in range(counts[i]):\n            result.append(i)\n    return result\n```","x":1135,"y":4916,"width":526,"height":307},
		{"id":"55a2e901195167de","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":-1326,"y":3894,"width":331,"height":119},
		{"id":"8f17c2548c397f83","type":"text","text":"```Python\ndef merge_sort(nums: list[int]) -> list[int]:\n    if len(nums) == 1:\n        return nums\n    m = len(nums) // 2\n    return _merge_sorted_lists(merge_sort(nums[:m]), merge_sort(nums[m:]))\n\n\ndef _merge_sorted_lists(l: list[int], r: list[int]) -> list[int]:\n    result = []\n    i = j = 0\n    while i != len(l) and j != len(r):\n        if (a := l[i]) <= (b := r[j]):\n            result.append(a)\n            i += 1\n        else:\n            result.append(b)\n            j += 1\n    result.extend(l[i:] if i != len(l) else r[j:])\n    return result\n```","x":-825,"y":3499,"width":755,"height":530},
		{"id":"fcfae4482fb55c6e","type":"text","text":"- Step1: 把 original array 從中間切成兩半\n- Step2: 將兩半各自排序好\n    - 若有某半只剩一個元素，則該半是排序好的\n    - 若有某半剩不止一個元素，則對該半重複 Step1\n- Step3: 將排序好的兩半合併","x":-1386,"y":3340,"width":451,"height":283},
		{"id":"12dae10d294894a6","type":"text","text":"divide and conquer","x":-1729,"y":3452,"width":215,"height":60},
		{"id":"3a83ff2d9ae955a9","type":"text","text":"```Python\ndef in_place_quick_sort(nums: list[int]) -> list[int]:\n    _helper(nums, 0, len(nums) - 1)\n    return nums\n\n\ndef _helper(nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n        return\n    i, j = l, r - 1\n    while i < j:\n        while nums[i] <= nums[r] and i < r:\n            i += 1\n        while nums[j] >= nums[r] and j > 0:\n            j -= 1\n        if i < j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n    if nums[r] < nums[i]:\n        nums[i], nums[r] = nums[r], nums[i]\n    _helper(nums, l, j)\n    _helper(nums, i + 1, r)\n```","x":821,"y":3424,"width":579,"height":597},
		{"id":"c08b64c589a09ba3","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":1568,"y":3875,"width":331,"height":119},
		{"id":"fcee396bb161a5dc","type":"text","text":"Auxiliary-Space Complexity 之所以會是 $O(n)$，是因為 recursive call 最多會有 n 次","x":1590,"y":4083,"width":287,"height":135},
		{"id":"5364188eb2e18c6e","type":"text","text":"#### In-Place Quick Sort","x":1597,"y":3690,"width":273,"height":65},
		{"id":"29aeca6933a203d6","type":"text","text":"#### Quick Select","x":1637,"y":3305,"width":193,"height":65},
		{"id":"ea23947aac362dfc","type":"text","text":"","x":1705,"y":3003,"width":250,"height":60},
		{"id":"a642f917eeea9d7e","type":"text","text":"```Python\n```","x":821,"y":2726,"width":579,"height":624},
		{"id":"0dffbfd56ab3472d","type":"text","text":"- Step1: 隨機選一個 original array 中的 pivot index，取得該 pivot index 的值 k\n- Step2: 將 array 分成 L、E、G 三份，其中 L 的所有元素都小於 k，E 的所有元素都等於 k，G 的所有元素都大於 k\n- Step3: 將 E 接在 L 後面，G 接在 E 後面\n- Step4: 將 L、G 分別排序好\n    - 若長度大於 1，則重複 Step1~Step3\n    - 若長度等於 1，那就已經排序好了","x":2098,"y":3165,"width":372,"height":410},
		{"id":"a83c49877d1ce656","type":"text","text":"divide and conquer","x":2567,"y":3340,"width":215,"height":60},
		{"id":"746bdd2de135edf1","type":"text","text":"```Python\ndef quick_sort(nums: list[int]) -> list[int]:\n    if len(nums) <= 1:\n        return nums\n    p = nums[0]\n    l, e, g = [], [], []\n    for num in nums:\n        if num == p:\n            e.append(num)\n        elif num > p:\n            g.append(num)\n        else:\n            l.append(num)\n    return quick_sort(l) + e + quick_sort(g)\n```","x":2567,"y":3525,"width":501,"height":396},
		{"id":"53a7f0d0d3a49433","type":"text","text":"#### Quick Sort","x":2197,"y":3690,"width":173,"height":65},
		{"id":"68bd984cbf522637","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":2118,"y":3875,"width":331,"height":119},
		{"id":"115472631b24bb5a","x":-1677,"y":4616,"width":367,"height":171,"type":"text","text":"決定 \"run\" 的方法（怎樣叫「夠小」？）：在 32 到 64 間選一個數字，使得這個元素總數 (n) 除以這個數字 (run) 後等於或小於但接近 2 的某次方"},
		{"id":"32b68fd252710ef2","type":"text","text":"表現比單純的 merge sort 好","x":-1589,"y":4847,"width":279,"height":64},
		{"id":"074fec693ebfedae","type":"text","text":"#### [Tim Sort](https://en.wikipedia.org/wiki/Timsort)","x":-1132,"y":5056,"width":168,"height":55},
		{"id":"670fd89cead04cc8","type":"text","text":"#### Merge Sort","x":-1250,"y":3736,"width":179,"height":56},
		{"id":"134611491f6362b8","type":"text","text":"#### BST Sort","x":1303,"y":1998,"width":153,"height":55}
	],
	"edges":[
		{"id":"f1b36731187a35fd","fromNode":"b239c4f621252170","fromSide":"top","toNode":"b571365cfbc44810","toSide":"bottom","label":"ideas"},
		{"id":"21653038e7a4c601","fromNode":"b239c4f621252170","fromSide":"right","toNode":"c05cbd6ca115a73f","toSide":"left","label":"code"},
		{"id":"ebd1ddbd9fbb9406","fromNode":"b239c4f621252170","fromSide":"bottom","toNode":"73ff9bbfea7ce88b","toSide":"top","label":"complexity"},
		{"id":"621365c052436f81","fromNode":"3ff105201d33ae16","fromSide":"top","toNode":"a77b2f8f083d24cb","toSide":"bottom","label":"ideas"},
		{"id":"185f2b33ca0c2835","fromNode":"3ff105201d33ae16","fromSide":"right","toNode":"0f214ef64bddf7d3","toSide":"left","label":"code"},
		{"id":"8427107fb5d9299c","fromNode":"3ff105201d33ae16","fromSide":"bottom","toNode":"39c0aff4325accff","toSide":"top","label":"complexity"},
		{"id":"1a899b327d22e428","fromNode":"3ff105201d33ae16","fromSide":"left","toNode":"93285d355c4a4aec","toSide":"right","fromEnd":"arrow"},
		{"id":"811897546e995db9","fromNode":"93285d355c4a4aec","fromSide":"left","toNode":"7910801f404a3a19","toSide":"right","label":"code"},
		{"id":"c1fcb511ab9aa394","fromNode":"93285d355c4a4aec","fromSide":"top","toNode":"98a1ec235945e259","toSide":"bottom","label":"ideas"},
		{"id":"52bbad0cb4deb0fb","fromNode":"93285d355c4a4aec","fromSide":"bottom","toNode":"e69ec252f26c7f17","toSide":"top","label":"complexity"},
		{"id":"43f607a527606cbc","fromNode":"3ff105201d33ae16","fromSide":"left","toNode":"2d6564c43ec63a03","toSide":"right"},
		{"id":"6305a4670c737e9e","fromNode":"2d6564c43ec63a03","fromSide":"top","toNode":"6c4680898ff60c73","toSide":"bottom","label":"ideas"},
		{"id":"ea2933395018822d","fromNode":"2d6564c43ec63a03","fromSide":"bottom","toNode":"fcd7d8a4440fecdc","toSide":"top","label":"complexity"},
		{"id":"45679afed2ce0b84","fromNode":"2d6564c43ec63a03","fromSide":"left","toNode":"c28e42e401df65f5","toSide":"right","label":"code"},
		{"id":"f758e5dab782716c","fromNode":"0436ceea87da2e3e","fromSide":"top","toNode":"238fb2e50f9313f9","toSide":"bottom","label":"ideas"},
		{"id":"f3870f8dee1aa5b9","fromNode":"0436ceea87da2e3e","fromSide":"right","toNode":"104c1cae4f4f3475","toSide":"left","label":"code"},
		{"id":"91edcf9cd96a8cd2","fromNode":"238fb2e50f9313f9","fromSide":"right","toNode":"f6ec54fcdef157a5","toSide":"left"},
		{"id":"a7e77bc39bc39e3e","fromNode":"0436ceea87da2e3e","fromSide":"bottom","toNode":"21546c66fbb84ba8","toSide":"top","label":"complexity"},
		{"id":"f94cd40a8b43ebdc","fromNode":"238fb2e50f9313f9","fromSide":"right","toNode":"540d7c093a4cbe68","toSide":"left"},
		{"id":"c7db265011fb6ddb","fromNode":"134611491f6362b8","fromSide":"top","toNode":"49fabe8895595128","toSide":"bottom","label":"ideas"},
		{"id":"a4d4f3b6a299419a","fromNode":"134611491f6362b8","fromSide":"right","toNode":"b099a8abcb8a817a","toSide":"left","label":"code"},
		{"id":"342a7c57238e0c31","fromNode":"134611491f6362b8","fromSide":"bottom","toNode":"9ee85fee782dd6ce","toSide":"top","label":"complexity"},
		{"id":"8584c0881f155e3d","fromNode":"0eafa24b413ce2b2","fromSide":"top","toNode":"4e54838da237b145","toSide":"bottom","label":"ideas"},
		{"id":"8086bf86ef3f5724","fromNode":"0eafa24b413ce2b2","fromSide":"right","toNode":"30eca70b868ae566","toSide":"left","label":"code"},
		{"id":"aad54df9682cb0f8","fromNode":"0eafa24b413ce2b2","fromSide":"bottom","toNode":"97681c6bb43c0713","toSide":"top","label":"complexity"},
		{"id":"2fa7170e4e058c0b","fromNode":"134611491f6362b8","fromSide":"left","toNode":"8a8df549279f0ee7","toSide":"right"},
		{"id":"b766365ad3299b2a","fromNode":"670fd89cead04cc8","fromSide":"top","toNode":"fcfae4482fb55c6e","toSide":"bottom","label":"ideas"},
		{"id":"66dda3a609276299","fromNode":"670fd89cead04cc8","fromSide":"right","toNode":"8f17c2548c397f83","toSide":"left","label":"code"},
		{"id":"3c8f064cbfcd7cff","fromNode":"670fd89cead04cc8","fromSide":"bottom","toNode":"55a2e901195167de","toSide":"top","label":"complexity"},
		{"id":"6afe71fea70e8208","fromNode":"fcfae4482fb55c6e","fromSide":"left","toNode":"12dae10d294894a6","toSide":"right"},
		{"id":"32b13f73fe3f76d7","fromNode":"53a7f0d0d3a49433","fromSide":"top","toNode":"0dffbfd56ab3472d","toSide":"bottom","label":"ideas"},
		{"id":"f0fab35440f7d6f9","fromNode":"53a7f0d0d3a49433","fromSide":"right","toNode":"746bdd2de135edf1","toSide":"left","label":"code"},
		{"id":"244d74de36eacb39","fromNode":"53a7f0d0d3a49433","fromSide":"bottom","toNode":"68bd984cbf522637","toSide":"top","label":"complexity"},
		{"id":"4ff84727000fbefb","fromNode":"53a7f0d0d3a49433","fromSide":"left","toNode":"5364188eb2e18c6e","toSide":"right","fromEnd":"arrow"},
		{"id":"700280a8a90957ad","fromNode":"5364188eb2e18c6e","fromSide":"bottom","toNode":"c08b64c589a09ba3","toSide":"top","label":"complexity"},
		{"id":"afae39740ba4a3e5","fromNode":"5364188eb2e18c6e","fromSide":"left","toNode":"3a83ff2d9ae955a9","toSide":"right","label":"code"},
		{"id":"4e21dc1646d044e7","fromNode":"0dffbfd56ab3472d","fromSide":"right","toNode":"a83c49877d1ce656","toSide":"left"},
		{"id":"ed0b37d41ae5983d","fromNode":"c08b64c589a09ba3","fromSide":"bottom","toNode":"fcee396bb161a5dc","toSide":"top"},
		{"id":"2274f5390e403a4f","fromNode":"074fec693ebfedae","fromSide":"top","toNode":"d69a7946c4b50c6b","toSide":"bottom","label":"ideas"},
		{"id":"f5d13708aed836d6","fromNode":"074fec693ebfedae","fromSide":"left","toNode":"50c261911d82ee44","toSide":"right"},
		{"id":"9efe36a833ecbc2a","fromNode":"d69a7946c4b50c6b","fromSide":"left","toNode":"32b68fd252710ef2","toSide":"right"},
		{"id":"78b6a9b558521733","fromNode":"074fec693ebfedae","fromSide":"right","toNode":"911a07c2189041e8","toSide":"left","label":"code"},
		{"id":"e4a3aa2754ec466c","fromNode":"074fec693ebfedae","fromSide":"bottom","toNode":"5ec23a0b444df1b0","toSide":"top","label":"complexity"},
		{"id":"31df2a4cc5ddbf3a","fromNode":"69ced796d4531c1b","fromSide":"top","toNode":"5c7057e4ced9f40a","toSide":"bottom","label":"ideas"},
		{"id":"f3865ae9c7f630f8","fromNode":"69ced796d4531c1b","fromSide":"left","toNode":"d10520631afaf9e9","toSide":"right","label":"缺點"},
		{"id":"79f925cc4f90be52","fromNode":"69ced796d4531c1b","fromSide":"bottom","toNode":"b8a89c7ad719f60e","toSide":"top"},
		{"id":"efedeba97d5c89c4","fromNode":"b8a89c7ad719f60e","fromSide":"bottom","toNode":"d860979a939c0b8e","toSide":"top"},
		{"id":"00d739f5a81de10d","fromNode":"69ced796d4531c1b","fromSide":"right","toNode":"da90a71b1cefabd2","toSide":"left","label":"code"},
		{"id":"6cf0ce75490216c4","fromNode":"53a7f0d0d3a49433","fromSide":"left","toNode":"29aeca6933a203d6","toSide":"bottom"},
		{"id":"bbc02994695aa9ed","fromNode":"fcd7d8a4440fecdc","fromSide":"right","toNode":"3f54d2c97748bacd","toSide":"left"},
		{"id":"72410d3c0fafa382","fromNode":"0eafa24b413ce2b2","fromSide":"left","toNode":"2b54e5495199d551","toSide":"right"},
		{"id":"ff65f24a7a7573e1","fromNode":"29aeca6933a203d6","fromSide":"top","toNode":"ea23947aac362dfc","toSide":"bottom","label":"ideas"},
		{"id":"1734d240553a3e1f","fromNode":"29aeca6933a203d6","fromSide":"left","toNode":"a642f917eeea9d7e","toSide":"right","label":"code"},
		{"id":"aa07375aec6e3e80","fromNode":"d69a7946c4b50c6b","fromSide":"left","toNode":"115472631b24bb5a","toSide":"right"}
	]
}