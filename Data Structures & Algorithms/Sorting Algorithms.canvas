{
	"nodes":[
		{"id":"3f54d2c97748bacd","type":"text","text":"因為 `insert` 的 time complexity 還是 $O(n)$，所以整體的 time complexity 還是 $O(n^2)$","x":2192,"y":1054,"width":313,"height":135},
		{"id":"3ff105201d33ae16","type":"text","text":"#### Insertion Sort","x":2529,"y":424,"width":214,"height":61,"color":"5"},
		{"id":"0f214ef64bddf7d3","type":"text","text":"```Python\ndef insertion_sort(nums: list[int]) -> list[int]:\n    result = []\n    while nums:\n        num = nums.pop()\n\n        # linear search\n        idx = 0\n        while idx < len(result):\n            if result[idx] >= num:\n                break\n            idx += 1\n\n        result.insert(idx, num)\n    return result\n```","x":2924,"y":246,"width":533,"height":418},
		{"id":"c28e42e401df65f5","type":"text","text":"```Python\ndef insertion_sort_with_binary_search(nums: list[int]) -> list[int]:\n    result = []\n    while nums:\n        num = nums.pop()\n\n        # binary search\n        l, r = 0, len(result) - 1\n        while l < r:\n            m = (l+r) // 2\n            if result[m] > num:\n                r = m\n            elif result[m] < num:\n                l = m + 1\n            else:\n                l = r = m\n        if len(result) > l and result[l] < num:\n            result.insert(l + 1, num)\n        else:\n            result.insert(l, num)\n    return result\n```","x":926,"y":609,"width":703,"height":552},
		{"id":"98a1ec235945e259","type":"text","text":"直接把 original array 的前端當作 sorted array，找新元素適合的位置時，從 sorted array 的尾端開始找","x":1757,"y":-170,"width":335,"height":135},
		{"id":"2d6564c43ec63a03","type":"text","text":"#### Insertion Sort with Binary Search","x":1789,"y":833,"width":270,"height":103,"color":"5"},
		{"id":"7910801f404a3a19","type":"text","text":"```Python\ndef in_place_insertion_sort(nums: list[int]) -> list[int]:\n    for i in range(1, len(nums)):\n        for j in range(i - 1, -1, -1):\n            k = j + 1\n            if nums[k] < nums[j]:\n                nums[k], nums[j] = nums[j], nums[k]\n            else:\n                break\n    return nums\n```","x":1014,"y":-15,"width":615,"height":307},
		{"id":"93285d355c4a4aec","type":"text","text":"#### In-Place Insertion Sort","x":1767,"y":106,"width":314,"height":65,"color":"5"},
		{"id":"e69ec252f26c7f17","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":1760,"y":323,"width":329,"height":119},
		{"id":"238fb2e50f9313f9","type":"text","text":"- Step1: 比較 original array 中的第一個元素與第二個元素的大小，如果第一個元素比較大就將他們兩個的位置對調。以相同的方法比較第二個元素與第三個元素、第三個元素與第四個元素 ...... 直到比完倒數第二個元素與最後一個元素為止。比完後，original array 的最後一個元素一定會是整個 array 中最大的數字，這樣就排好了一個\n- Step2: 重複 Step1（但這次不用再管最後一個元素）就可以將第二大的元素放到倒數第二個位置。一直重複，每次都可以少看一個尾端的元素，直到整個 array 排完","x":-562,"y":124,"width":498,"height":350},
		{"id":"21546c66fbb84ba8","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":-481,"y":889,"width":329,"height":119},
		{"id":"0436ceea87da2e3e","type":"text","text":"#### Bubble Sort","x":-410,"y":684,"width":187,"height":58,"color":"5"},
		{"id":"104c1cae4f4f3475","type":"text","text":"```Python\ndef bubble_sort(nums: list[int]) -> list[int]:\n    sorted_head_idx = len(nums)\n    while sorted_head_idx != 0:\n        next_sorted_head_idx = 0\n        for i in range(sorted_head_idx - 1):\n            j = i + 1\n            if nums[i] > nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                next_sorted_head_idx = j\n        sorted_head_idx = next_sorted_head_idx\n    return nums\n```","x":-10,"y":538,"width":556,"height":351},
		{"id":"f6ec54fcdef157a5","type":"text","text":"因為每一輪都會找到 unsorted part 中最大的元素並將其放到 unsorted part 的最底部（成為 sorted part），所以又叫做 **sink sort**","x":79,"y":124,"width":335,"height":171},
		{"id":"540d7c093a4cbe68","type":"text","text":"Bubble sort 天生就是 in-place 的演算法","x":79,"y":374,"width":378,"height":64},
		{"id":"c05cbd6ca115a73f","type":"text","text":"```Python\ndef selection_sort(nums: list[int]) -> list[int]:\n    result = []\n    while nums:\n        min_ = min(nums)\n        nums.remove(min_)\n        result.append(min_)\n    return result\n```","x":-1438,"y":441,"width":589,"height":262},
		{"id":"b099a8abcb8a817a","type":"text","text":"```Python\ndef bst_sort(nums: list[int]) -> list[int]:\n    class Node:\n        def __init__(self, val: int) -> None:\n            self.val = val\n            self.left: Node | None = None\n            self.right: Node | None = None\n\n    # build BST\n    root = Node(nums.pop())\n    for num in nums:\n        temp = root\n        while temp:\n            if num < temp.val and temp.left:\n                temp = temp.left\n            elif num >= temp.val and temp.right:\n                temp = temp.right\n            else:\n                break\n        if num < temp.val:\n            temp.left = Node(num)\n        else:\n            temp.right = Node(num)\n\n    result = []\n\n    def in_order_traverse(node: Node | None) -> None:\n        if node is None:\n            return\n        in_order_traverse(node.left)\n        result.append(node.val)\n        in_order_traverse(node.right)\n\n    in_order_traverse(root)\n    return result\n```","x":899,"y":1593,"width":570,"height":865},
		{"id":"30eca70b868ae566","type":"text","text":"```Python\nimport heapq\n\ndef heap_sort(nums: list[int]) -> list[int]:\n    heapq.heapify(nums)\n    return [heapq.heappop(nums) for _ in range(len(nums))]\n```","x":-719,"y":1935,"width":612,"height":205},
		{"id":"0eafa24b413ce2b2","type":"text","text":"#### Heap Sort","x":-1055,"y":2010,"width":167,"height":55,"color":"5"},
		{"id":"8a8df549279f0ee7","type":"text","text":"[[從 Binary Search 到 B+ Tree#BST (Binary Search Tree)|Binary Search Tree]]","x":127,"y":1996,"width":214,"height":60},
		{"id":"2b54e5495199d551","type":"file","file":"Data Structures & Algorithms/Binary Heap.md","x":-1872,"y":1838,"width":649,"height":400},
		{"id":"134611491f6362b8","type":"text","text":"#### BST Sort","x":503,"y":1998,"width":153,"height":55,"color":"5"},
		{"id":"d10520631afaf9e9","type":"text","text":"只能排序數字或是有數字編號的東西","x":1084,"y":5587,"width":195,"height":95},
		{"id":"d860979a939c0b8e","type":"text","text":"m 為 original array 中最大數字與最小數字的差","x":1424,"y":5982,"width":250,"height":100},
		{"id":"69ced796d4531c1b","type":"text","text":"#### Counting Sort","x":1443,"y":5602,"width":211,"height":61,"color":"5"},
		{"id":"da90a71b1cefabd2","type":"text","text":"```Python\ndef counting_sort(nums: list[int]) -> list[int]:\n    counts = [0] * (max(nums) +1)\n    for num in nums:\n        counts[num] += 1\n    result = []\n    for i in range(len(counts)):\n        for _ in range(counts[i]):\n            result.append(i)\n    return result\n```","x":1802,"y":5481,"width":526,"height":307},
		{"id":"911a07c2189041e8","type":"text","text":"```Python\ndef tim_sort(nums: list[int]) -> list[int]:\n    def in_place_insertion_sort(nums: list[int], start: int, end: int) -> None:\n        len_ = end - start + 1\n        for i in range(1, len_):\n            for j in range(start + i - 1, start - 1, -1):\n                k = j + 1\n                if nums[k] < nums[j]:\n                    nums[k], nums[j] = nums[j], nums[k]\n                else:\n                    break\n\n    def in_place_merge_sorted_lists(\n        nums: list[int], start: int, mid: int, end: int\n    ) -> None:\n        if start == mid or mid >= end:\n            return\n        left, right = nums[start : mid + 1], nums[mid + 1 : end + 1]\n        i, j, k = 0, 0, start\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n\n    run = 32\n    for i in range(0, len(nums), run):\n        in_place_insertion_sort(nums, i, min(i + run - 1, len(nums) - 1))\n    while run < len(nums):\n        for i in range(0, len(nums), 2 * run):\n            in_place_merge_sorted_lists(\n                nums,\n                i,\n                min(i + run - 1, len(nums) - 1),\n                min(i + 2 * run - 1, len(nums) - 1),\n            )\n        run *= 2\n    return nums\n```","x":-272,"y":5219,"width":806,"height":1177},
		{"id":"115472631b24bb5a","type":"text","text":"決定 \"run\" 的方法（怎樣叫「夠小」？）：在 32 到 64 間選一個數字，使得這個元素總數 (n) 除以這個數字 (run) 後等於或小於但接近 2 的某次方","x":-1170,"y":5341,"width":367,"height":171},
		{"id":"d69a7946c4b50c6b","type":"text","text":"原則上使用 merge sort，但當 array 被分割得「夠小」時，改用 in-place insertion sort","x":-690,"y":5536,"width":288,"height":135},
		{"id":"50c261911d82ee44","type":"text","text":"Python 的 `sorted` 所使用的演算法就是 tim sort","x":-987,"y":5758,"width":253,"height":100},
		{"id":"32b68fd252710ef2","type":"text","text":"表現比單純的 merge sort 好","x":-1082,"y":5572,"width":279,"height":64},
		{"id":"074fec693ebfedae","type":"text","text":"#### [Tim Sort](https://en.wikipedia.org/wiki/Timsort)","x":-625,"y":5781,"width":168,"height":55,"color":"5"},
		{"id":"12dae10d294894a6","type":"text","text":"divide and conquer","x":1730,"y":1827,"width":211,"height":60},
		{"id":"8f17c2548c397f83","type":"text","text":"```Python\ndef merge_sort(nums: list[int]) -> list[int]:\n    if len(nums) == 1:\n        return nums\n    m = len(nums) // 2\n    return _merge_sorted_lists(merge_sort(nums[:m]), merge_sort(nums[m:]))\n\n\ndef _merge_sorted_lists(l: list[int], r: list[int]) -> list[int]:\n    result = []\n    i = j = 0\n    while i != len(l) and j != len(r):\n        if (a := l[i]) <= (b := r[j]):\n            result.append(a)\n            i += 1\n        else:\n            result.append(b)\n            j += 1\n    result.extend(l[i:] if i != len(l) else r[j:])\n    return result\n```","x":2634,"y":1874,"width":755,"height":530},
		{"id":"670fd89cead04cc8","type":"text","text":"#### Merge Sort","x":2209,"y":2111,"width":179,"height":56,"color":"5"},
		{"id":"ea23947aac362dfc","type":"text","text":"Quick Select 其實就是 quick sort 的閹割版，且也有分 in-place 跟非 in-place 之分","x":719,"y":3143,"width":281,"height":135},
		{"id":"29aeca6933a203d6","type":"text","text":"#### Quick Select","x":812,"y":3480,"width":193,"height":65,"color":"5"},
		{"id":"746bdd2de135edf1","type":"text","text":"```Python\ndef quick_sort(nums: list[int]) -> list[int]:\n    if len(nums) <= 1:\n        return nums\n    p = nums.pop(0)\n    l, e, g = [], [p], []\n    for num in nums:\n        if num == p:\n            e.append(num)\n        elif num > p:\n            g.append(num)\n        else:\n            l.append(num)\n    return quick_sort(l) + e + quick_sort(g)\n```","x":1742,"y":3940,"width":501,"height":396},
		{"id":"71f8e985d3e66f65","type":"text","text":"在未排序的 array 中找出第 k 小的數","x":1048,"y":3296,"width":197,"height":94},
		{"id":"f480ca8de25a86a2","type":"text","text":"```Python\ndef quick_select(nums: list[int], k: int) -> int:\n    pivot = nums.pop()\n    l, e, g = [], [pivot], []\n    for num in nums:\n        if num == pivot:\n            e.append(num)\n        elif num > pivot:\n            g.append(num)\n        else:\n            l.append(num)\n    if len(l) >= k:\n        return quick_select(l, k)\n    if len(e) >= k - len(l):\n        return e[0]\n    return quick_select(g, k - len(l) - len(e))\n```\n\n###### In-Place Quick Select\n\n```Python\ndef in_place_quick_select(nums: list[int], k: int) -> int:\n    return _in_place_quick_select_helper(nums, k, 0, len(nums) - 1)\n\n\ndef _in_place_quick_select_helper(nums: list[int], k: int, l: int, r: int) -> int:\n    pivot = nums[r]\n    i, j = l, r - 1\n    while i < j:\n        while nums[i] <= pivot:  # the `=` here makes `i` the pivot index\n            i += 1\n        while nums[j] > pivot:\n            j -= 1\n        if i < j:\n            nums[i], nums[j] = nums[j], nums[i]\n    nums[i], nums[r] = nums[r], nums[i]  # move pivot number to the pivot index\n    if i + 1 == k:\n        return nums[i]\n    elif i + 1 > k:\n        return _in_place_quick_select_helper(nums, k, l, i - 1)\n    else:\n        return _in_place_quick_select_helper(nums, k, i + 1, r)\n```","x":-247,"y":2805,"width":828,"height":1034},
		{"id":"fcfae4482fb55c6e","type":"text","text":"- Step1: 把 original array 從中間切成兩半\n- Step2: 將兩半各自排序好\n    - 若有某半只剩一個元素，則該半是排序好的\n    - 若有某半剩不止一個元素，則對該半重複 Step1\n- Step3: 將排序好的兩半合併","x":2064,"y":1715,"width":470,"height":283},
		{"id":"55a2e901195167de","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":2122,"y":2269,"width":353,"height":119},
		{"id":"49fabe8895595128","type":"text","text":"- Step1: 將 original array 中的元素逐一放入一個 BST (binary-search tree) 中\n- Step2: 使用 in-order traversal 的方式遍歷整棵 BST 即得到 sorted array","x":390,"y":1695,"width":379,"height":190},
		{"id":"9ee85fee782dd6ce","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":403,"y":2194,"width":353,"height":119},
		{"id":"5ec23a0b444df1b0","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":-717,"y":5968,"width":353,"height":119},
		{"id":"b8a89c7ad719f60e","type":"text","text":"\n- Time complexity: $O(n + m)$\n- Auxiliary-Space Complexity: $O(n + m)$","x":1354,"y":5788,"width":389,"height":119},
		{"id":"5c7057e4ced9f40a","type":"text","text":"- Step1: 走訪 original array 一遍，由小到大紀錄每個數字出現幾次\n- Step2: 建立一個空的 sorted array，把 Step1 紀錄的數字由小到大填入每個數字填入 n 次，n 為記錄到該數字的出現次數","x":1350,"y":5263,"width":398,"height":226},
		{"id":"c08b64c589a09ba3","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-space complexity: $O(n)$","x":204,"y":4078,"width":348,"height":119},
		{"id":"97681c6bb43c0713","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-Space Complexity: $O(n)$","x":-1148,"y":2238,"width":353,"height":119},
		{"id":"4e54838da237b145","type":"text","text":"- Step1: 將 original array 中的元素逐一放進一個 min heap 中\n- Step2: 持續 pop min heap 的 root，直到 min heap 沒有元素為止","x":-1150,"y":1681,"width":358,"height":190},
		{"id":"39c0aff4325accff","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":2461,"y":647,"width":351,"height":119},
		{"id":"a77b2f8f083d24cb","type":"text","text":"- Step1: 建立一個空的 sorted array\n- Step2: 從 original array 中拿出（移除）第一個元素（或最後一個），找到 sorted array 中適合放入此元素的位置並將其放入\n- Step3: 重複 Step2 直到 original array 沒有東西為止","x":2390,"y":38,"width":492,"height":242},
		{"id":"6c4680898ff60c73","type":"text","text":"本來 insertion sort 在將元素放進 sorted array 時，是用 linear search 找適合的位置，但其實這部分可以用 binary search 來加速","x":1718,"y":580,"width":413,"height":135},
		{"id":"fcd7d8a4440fecdc","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":1749,"y":1062,"width":351,"height":119},
		{"id":"b239c4f621252170","type":"text","text":"#### Selection Sort","x":-1778,"y":542,"width":221,"height":58,"color":"5"},
		{"id":"73ff9bbfea7ce88b","type":"text","text":"\n- Time complexity: $O(n^2)$\n- Auxiliary-Space Complexity: $O(1)$","x":-1856,"y":769,"width":377,"height":120},
		{"id":"b571365cfbc44810","type":"text","text":"- Step1: 建立一個空的 sorted array\n- Step2: 找到並拿出（移除）original array 中最小的元素，然後將該元素放入 sorted array 的末端\n- Step3: 重複 Step2 直到 original array 沒有東西為止","x":-1928,"y":165,"width":522,"height":209},
		{"id":"53a7f0d0d3a49433","type":"text","text":"#### Quick Sort","x":1371,"y":4109,"width":180,"height":58,"color":"5"},
		{"id":"68bd984cbf522637","type":"text","text":"\n- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-space complexity: $O(n)$","x":1274,"y":4336,"width":373,"height":120},
		{"id":"0dffbfd56ab3472d","type":"text","text":"- Step1: 隨機選一個 original array 中的 pivot index，取得該 pivot index 的值 k\n- Step2: 將 array 分成 L、E、G 三份，其中 L 的所有元素都小於 k，E 的所有元素都等於 k，G 的所有元素都大於 k\n- Step3: 將 E 接在 L 後面，G 接在 E 後面\n- Step4: 將 L、G 分別排序好\n    - 若長度大於 1，則重複 Step1~Step3\n    - 若長度等於 1，那就已經排序好了","x":1249,"y":3447,"width":424,"height":416},
		{"id":"a83c49877d1ce656","type":"text","text":"divide and conquer","x":1780,"y":3626,"width":213,"height":58},
		{"id":"2eeacdf42b9e7a62","type":"text","text":"- Time complexity: $O(n \\cdot \\log n)$\n- Auxiliary-space complexity: $O(n)$","x":722,"y":3655,"width":373,"height":120},
		{"id":"663f14e16b6dd853","type":"text","text":"Auxiliary-space complexity 之所以會是 $O(n)$，是因為 recursive call 最多會有 n 次","x":709,"y":3863,"width":399,"height":99},
		{"id":"5364188eb2e18c6e","type":"text","text":"#### In-Place Quick Sort","x":766,"y":4109,"width":286,"height":58,"color":"5"},
		{"id":"3a83ff2d9ae955a9","type":"text","text":"```Python\ndef in_place_quick_sort(nums: list[int]) -> list[int]:\n    _helper(nums, 0, len(nums) - 1)\n    return nums\n\n\ndef _helper(nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n        return\n    i, j = l, r - 1\n    while i < j:\n        while nums[i] <= nums[r] and i < r:\n            i += 1\n        while nums[j] >= nums[r] and j > 0:\n            j -= 1\n        if i < j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n    if nums[r] < nums[i]:\n        nums[i], nums[r] = nums[r], nums[i]\n    _helper(nums, l, j)\n    _helper(nums, i + 1, r)\n```","x":594,"y":4292,"width":630,"height":618}
	],
	"edges":[
		{"id":"f1b36731187a35fd","fromNode":"b239c4f621252170","fromSide":"top","toNode":"b571365cfbc44810","toSide":"bottom","label":"ideas"},
		{"id":"21653038e7a4c601","fromNode":"b239c4f621252170","fromSide":"right","toNode":"c05cbd6ca115a73f","toSide":"left","label":"code"},
		{"id":"ebd1ddbd9fbb9406","fromNode":"b239c4f621252170","fromSide":"bottom","toNode":"73ff9bbfea7ce88b","toSide":"top","label":"complexity"},
		{"id":"621365c052436f81","fromNode":"3ff105201d33ae16","fromSide":"top","toNode":"a77b2f8f083d24cb","toSide":"bottom","label":"ideas"},
		{"id":"185f2b33ca0c2835","fromNode":"3ff105201d33ae16","fromSide":"right","toNode":"0f214ef64bddf7d3","toSide":"left","label":"code"},
		{"id":"8427107fb5d9299c","fromNode":"3ff105201d33ae16","fromSide":"bottom","toNode":"39c0aff4325accff","toSide":"top","label":"complexity"},
		{"id":"1a899b327d22e428","fromNode":"3ff105201d33ae16","fromSide":"left","toNode":"93285d355c4a4aec","toSide":"right","fromEnd":"arrow"},
		{"id":"811897546e995db9","fromNode":"93285d355c4a4aec","fromSide":"left","toNode":"7910801f404a3a19","toSide":"right","label":"code"},
		{"id":"c1fcb511ab9aa394","fromNode":"93285d355c4a4aec","fromSide":"top","toNode":"98a1ec235945e259","toSide":"bottom","label":"ideas"},
		{"id":"52bbad0cb4deb0fb","fromNode":"93285d355c4a4aec","fromSide":"bottom","toNode":"e69ec252f26c7f17","toSide":"top","label":"complexity"},
		{"id":"43f607a527606cbc","fromNode":"3ff105201d33ae16","fromSide":"left","toNode":"2d6564c43ec63a03","toSide":"right"},
		{"id":"6305a4670c737e9e","fromNode":"2d6564c43ec63a03","fromSide":"top","toNode":"6c4680898ff60c73","toSide":"bottom","label":"ideas"},
		{"id":"ea2933395018822d","fromNode":"2d6564c43ec63a03","fromSide":"bottom","toNode":"fcd7d8a4440fecdc","toSide":"top","label":"complexity"},
		{"id":"45679afed2ce0b84","fromNode":"2d6564c43ec63a03","fromSide":"left","toNode":"c28e42e401df65f5","toSide":"right","label":"code"},
		{"id":"f758e5dab782716c","fromNode":"0436ceea87da2e3e","fromSide":"top","toNode":"238fb2e50f9313f9","toSide":"bottom","label":"ideas"},
		{"id":"f3870f8dee1aa5b9","fromNode":"0436ceea87da2e3e","fromSide":"right","toNode":"104c1cae4f4f3475","toSide":"left","label":"code"},
		{"id":"91edcf9cd96a8cd2","fromNode":"238fb2e50f9313f9","fromSide":"right","toNode":"f6ec54fcdef157a5","toSide":"left"},
		{"id":"a7e77bc39bc39e3e","fromNode":"0436ceea87da2e3e","fromSide":"bottom","toNode":"21546c66fbb84ba8","toSide":"top","label":"complexity"},
		{"id":"f94cd40a8b43ebdc","fromNode":"238fb2e50f9313f9","fromSide":"right","toNode":"540d7c093a4cbe68","toSide":"left"},
		{"id":"c7db265011fb6ddb","fromNode":"134611491f6362b8","fromSide":"top","toNode":"49fabe8895595128","toSide":"bottom","label":"ideas"},
		{"id":"a4d4f3b6a299419a","fromNode":"134611491f6362b8","fromSide":"right","toNode":"b099a8abcb8a817a","toSide":"left","label":"code"},
		{"id":"342a7c57238e0c31","fromNode":"134611491f6362b8","fromSide":"bottom","toNode":"9ee85fee782dd6ce","toSide":"top","label":"complexity"},
		{"id":"8584c0881f155e3d","fromNode":"0eafa24b413ce2b2","fromSide":"top","toNode":"4e54838da237b145","toSide":"bottom","label":"ideas"},
		{"id":"8086bf86ef3f5724","fromNode":"0eafa24b413ce2b2","fromSide":"right","toNode":"30eca70b868ae566","toSide":"left","label":"code"},
		{"id":"aad54df9682cb0f8","fromNode":"0eafa24b413ce2b2","fromSide":"bottom","toNode":"97681c6bb43c0713","toSide":"top","label":"complexity"},
		{"id":"2fa7170e4e058c0b","fromNode":"134611491f6362b8","fromSide":"left","toNode":"8a8df549279f0ee7","toSide":"right"},
		{"id":"b766365ad3299b2a","fromNode":"670fd89cead04cc8","fromSide":"top","toNode":"fcfae4482fb55c6e","toSide":"bottom","label":"ideas"},
		{"id":"66dda3a609276299","fromNode":"670fd89cead04cc8","fromSide":"right","toNode":"8f17c2548c397f83","toSide":"left","label":"code"},
		{"id":"3c8f064cbfcd7cff","fromNode":"670fd89cead04cc8","fromSide":"bottom","toNode":"55a2e901195167de","toSide":"top","label":"complexity"},
		{"id":"6afe71fea70e8208","fromNode":"fcfae4482fb55c6e","fromSide":"left","toNode":"12dae10d294894a6","toSide":"right"},
		{"id":"32b13f73fe3f76d7","fromNode":"53a7f0d0d3a49433","fromSide":"top","toNode":"0dffbfd56ab3472d","toSide":"bottom","label":"ideas"},
		{"id":"f0fab35440f7d6f9","fromNode":"53a7f0d0d3a49433","fromSide":"right","toNode":"746bdd2de135edf1","toSide":"left","label":"code"},
		{"id":"244d74de36eacb39","fromNode":"53a7f0d0d3a49433","fromSide":"bottom","toNode":"68bd984cbf522637","toSide":"top","label":"complexity"},
		{"id":"4ff84727000fbefb","fromNode":"53a7f0d0d3a49433","fromSide":"left","toNode":"5364188eb2e18c6e","toSide":"right","fromEnd":"arrow"},
		{"id":"700280a8a90957ad","fromNode":"5364188eb2e18c6e","fromSide":"left","toNode":"c08b64c589a09ba3","toSide":"right","label":"complexity"},
		{"id":"afae39740ba4a3e5","fromNode":"5364188eb2e18c6e","fromSide":"bottom","toNode":"3a83ff2d9ae955a9","toSide":"top","label":"code"},
		{"id":"4e21dc1646d044e7","fromNode":"0dffbfd56ab3472d","fromSide":"right","toNode":"a83c49877d1ce656","toSide":"left"},
		{"id":"2274f5390e403a4f","fromNode":"074fec693ebfedae","fromSide":"top","toNode":"d69a7946c4b50c6b","toSide":"bottom","label":"ideas"},
		{"id":"f5d13708aed836d6","fromNode":"074fec693ebfedae","fromSide":"left","toNode":"50c261911d82ee44","toSide":"right"},
		{"id":"9efe36a833ecbc2a","fromNode":"d69a7946c4b50c6b","fromSide":"left","toNode":"32b68fd252710ef2","toSide":"right"},
		{"id":"78b6a9b558521733","fromNode":"074fec693ebfedae","fromSide":"right","toNode":"911a07c2189041e8","toSide":"left","label":"code"},
		{"id":"e4a3aa2754ec466c","fromNode":"074fec693ebfedae","fromSide":"bottom","toNode":"5ec23a0b444df1b0","toSide":"top","label":"complexity"},
		{"id":"31df2a4cc5ddbf3a","fromNode":"69ced796d4531c1b","fromSide":"top","toNode":"5c7057e4ced9f40a","toSide":"bottom","label":"ideas"},
		{"id":"f3865ae9c7f630f8","fromNode":"69ced796d4531c1b","fromSide":"left","toNode":"d10520631afaf9e9","toSide":"right","label":"缺點"},
		{"id":"79f925cc4f90be52","fromNode":"69ced796d4531c1b","fromSide":"bottom","toNode":"b8a89c7ad719f60e","toSide":"top"},
		{"id":"efedeba97d5c89c4","fromNode":"b8a89c7ad719f60e","fromSide":"bottom","toNode":"d860979a939c0b8e","toSide":"top"},
		{"id":"00d739f5a81de10d","fromNode":"69ced796d4531c1b","fromSide":"right","toNode":"da90a71b1cefabd2","toSide":"left","label":"code"},
		{"id":"6cf0ce75490216c4","fromNode":"53a7f0d0d3a49433","fromSide":"left","toNode":"29aeca6933a203d6","toSide":"right"},
		{"id":"bbc02994695aa9ed","fromNode":"fcd7d8a4440fecdc","fromSide":"right","toNode":"3f54d2c97748bacd","toSide":"left"},
		{"id":"72410d3c0fafa382","fromNode":"0eafa24b413ce2b2","fromSide":"left","toNode":"2b54e5495199d551","toSide":"right"},
		{"id":"ff65f24a7a7573e1","fromNode":"29aeca6933a203d6","fromSide":"top","toNode":"ea23947aac362dfc","toSide":"bottom","label":"ideas"},
		{"id":"aa07375aec6e3e80","fromNode":"d69a7946c4b50c6b","fromSide":"left","toNode":"115472631b24bb5a","toSide":"right"},
		{"id":"f5fdc8f041cedad2","fromNode":"29aeca6933a203d6","fromSide":"top","toNode":"71f8e985d3e66f65","toSide":"bottom","label":"目標"},
		{"id":"029e264b1bad0f6c","fromNode":"29aeca6933a203d6","fromSide":"bottom","toNode":"2eeacdf42b9e7a62","toSide":"top","label":"complexity"},
		{"id":"2a252af5b05045f1","fromNode":"29aeca6933a203d6","fromSide":"left","toNode":"f480ca8de25a86a2","toSide":"right","label":"code"},
		{"id":"6a55bfb9080041a6","fromNode":"2eeacdf42b9e7a62","fromSide":"bottom","toNode":"663f14e16b6dd853","toSide":"top"},
		{"id":"1eb6768c4cca5a14","fromNode":"c08b64c589a09ba3","fromSide":"top","toNode":"663f14e16b6dd853","toSide":"left"}
	]
}