{
	"nodes":[
		{"id":"1fb785f1e3df49dd","type":"group","x":-297,"y":161,"width":1276,"height":140,"label":"變體"},
		{"id":"e30480a497a782cb","type":"group","x":210,"y":-785,"width":1069,"height":104,"label":"Policies"},
		{"id":"d7f853006833e89a","type":"text","text":"recency based policy","x":230,"y":-765,"width":226,"height":61},
		{"id":"fabe16447b626521","type":"text","text":"frequency-based policy","x":535,"y":-765,"width":248,"height":64},
		{"id":"46cc83bda5c9aaab","type":"text","text":"在有限的空間中決定要將哪些資料 cache，以極大化 cache hit 的機率","x":1249,"y":-1084,"width":247,"height":135},
		{"id":"ae2367a7bbcaafba","type":"text","text":"## Cache  Replacement Policy","x":405,"y":-1066,"width":682,"height":100,"color":"6"},
		{"id":"1ba328a217da69f0","type":"file","file":"System Design/Caching.canvas","x":56,"y":-1366,"width":305,"height":256},
		{"id":"44d1fc4842b1ea2f","type":"text","text":"```Python\ntype primary = str | int | float | tuple[primary, ...]\n\nclass Node:\n    def __init__(self, key: primary, value) -> None:\n        self.key = key\n        self.value = value\n        self.prev: Node | None = None\n        self.next: Node | None = None\n\n\nclass LRUCache:\n    def __init__(self, size: int) -> None:\n        self.max_size = size\n        self.__storage = {}\n        self.__head: Node | None = None\n        self.__tail: Node | None = None\n\n    @property\n    def size(self) -> int:\n        return len(self.__storage)\n\n    def get(self, key: primary):\n        value = self.__storage[key].value\n        self.set(key, value)\n        return value\n\n    def set(self, key: primary, value) -> None:\n        # remove old node from the hash map and the linked list if found\n        if old_node := self.__storage.pop(key, None):\n            if self.__head and old_node is self.__head:\n                self.__head = self.__head.next\n            else:\n                old_node.prev.next = old_node.next\n            if self.__tail and old_node is self.__tail:\n                self.__tail = self.__tail.prev\n            else:\n                old_node.next.prev = old_node.prev\n\n        # remove head if capacity is full\n        if self.size >= self.max_size and self.__head:\n            del self.__storage[self.__head.key]\n            self.__head = self.__head.next\n\n        # create new node, put it into the hash map and the linked list\n        new_node = Node(key, value)\n        self.__storage[key] = new_node\n        if not self.__head or not self.__tail:\n            self.__head = self.__tail = new_node\n        else:\n            new_node.prev = self.__tail\n            self.__tail.next = new_node\n            self.__tail = self.__tail.next\n```","x":-1085,"y":310,"width":737,"height":1266},
		{"id":"626cc11e548d08dd","type":"text","text":"#### LRU Cache with TTL, Fallback, and Thread Safety\n\n```Python\nfrom collections import OrderedDict\nfrom datetime import datetime, timedelta\nfrom threading import Lock\nfrom typing import Any, Callable\n\ntype primary = str | int | float | tuple[primary, ...]\n\n\nclass LRUCache:\n    def __init__(self, size: int, detault_ttl: int = 86400) -> None:\n        self.max_size = size\n        self.__storage = OrderedDict()\n        self.__lock = Lock()\n        self.__default_ttl = default_ttl\n        self.__expiration: dict[primary, datetime] = {}\n    \n    @property\n    def size(self) -> int:\n        return len(self.keys)\n\n    @property\n    def keys(self) -> list:\n        now = datetime.now()\n        return [key for key in self._storage if now <= self.__expiration[key]]\n\n    def get(\n        self,\n        key: primary,\n        refresh: bool = False,\n        refresh_ttl: int | None = None,\n        fallback: Callable | None = None,\n    ) -> Any:\n        now = datetime.now()\n        try:\n            if now > self.__expiration[key]:\n                del self._storage[key]\n                del self.__expiration[key]\n            value = self.__storage[key]\n        except KeyError:\n            if fallback is None:\n                raise Exception(\"Cache missed, and no fallback was provided.\")\n            value = fallback()\n        self.set(\n            key,\n            value,\n            ttl=(\n                refresh_ttl\n                if refresh\n                else int((self.__expiration[key] - now).total_seconds())\n            ),\n        )\n        return value\n\n    def set(self, key: primary, value: Any, ttl: int | None = None) -> None:\n        with self.__lock:\n            now = datetime.now()\n            ttl = ttl if ttl is not None else self.__default_ttl\n            self.__expiration[key] = now + timedelta(seconds=ttl)\n            if self.size >= self.max_size:\n                self._storage.popitem(last=False)\n            self.__storage[key] = value\n```","x":-1113,"y":2634,"width":793,"height":1526},
		{"id":"cf1e23f2491f1a52","type":"text","text":"- [相關文章 1](https://redis.com/glossary/cache-invalidation/)\n- [相關文章 2](https://en.wikipedia.org/wiki/Cache_replacement_policies)\n- [相關影片](https://www.youtube.com/watch?v=_Hh-NcdbHCY&sttick=0)","x":659,"y":-1366,"width":174,"height":161},
		{"id":"2de27ce6d945c0e2","type":"text","text":"又叫 cache eviction policy","x":1249,"y":-1220,"width":269,"height":64},
		{"id":"ed099004e18e097e","type":"text","text":"FIFO","x":1153,"y":-760,"width":96,"height":54},
		{"id":"8c82e459341bb6d7","type":"text","text":"random replacement","x":848,"y":-763,"width":227,"height":61},
		{"id":"b9cf4e474ec87dde","type":"text","text":"least frequently used","x":1019,"y":-431,"width":229,"height":61},
		{"id":"10b247dec221b176","type":"text","text":"- [相關文章1](https://redis.com/glossary/lru-cache/)\n- [相關文章2](https://www.enjoyalgorithms.com/blog/implement-least-recently-used-cache)\n- [Leetcode](https://leetcode.com/problems/lru-cache/)","x":-911,"y":-708,"width":170,"height":161},
		{"id":"9b41ba365c225fb7","type":"text","text":"多一個 doubly-linked list 紀錄順序","x":-825,"y":-14,"width":215,"height":96},
		{"id":"80612e3000c36eba","type":"text","text":"```Python\nfrom collections import OrderedDict\n\ntype primary = str | int | float | tuple[primary, ...]\n\n\nclass LRUCache:\n    def __init__(self, size: int) -> None:\n        self.max_size = size\n        self.__storage = OrderedDict()\n    \n    @property\n    def size(self) -> int:\n        return len(self.__storage)\n    \n    def get(self, key: primary):\n        value = self.__storage[key]\n        self.set(key, value)\n        return value\n    \n    def set(self, key: primary, value) -> None:\n        self._storage.pop(key, None)\n        if self.size >= self.max_size:\n            self.__storage.popitem(last=False)\n        self.__storage[key] = value\n```","x":-1055,"y":1766,"width":677,"height":665},
		{"id":"6b69ef02eb3c6368","type":"text","text":"有些程式語言中原生就有 lined hash map，比如 Java 的 `LinkedHashMap` 與 Python 的 `OrderedDict`","x":-1192,"y":-51,"width":279,"height":171},
		{"id":"4f2ad4230ce2e802","type":"text","text":"其實自從 Python3.7 後，一般的 `dict` 就是有序的，但是 `dict` 不支援從「頭」拿東西","x":-1580,"y":-33,"width":292,"height":135},
		{"id":"3cd4923f49b55a52","type":"file","file":"img/data-structures-for-lru-cache.png","x":-1734,"y":310,"width":590,"height":332},
		{"id":"8834d09658708173","type":"text","text":"應用：\n\n- 瀏覽器暫存網頁資源\n- OS 分配 memory page\n- [[CDN]]\n- Database cache","x":-982,"y":-481,"width":243,"height":289},
		{"id":"c05fd1b6fec3d86e","type":"text","text":"#### LFU Cache","x":1304,"y":-429,"width":175,"height":56,"color":"5"},
		{"id":"0b185278e27767dc","type":"text","text":"[Leetcode](https://leetcode.com/problems/lfu-cache/)","x":1677,"y":-644,"width":144,"height":60},
		{"id":"0302a51d5d88567f","type":"text","text":"缺點\n\n- 有可能存在一些因為過去很常被使用而在 cache 裡有很高 priority 的資料，這些資料可能現在不再需要了\n- LFU 比 LRU 難實作（所以實際應用中使用 LFU 的其實很少）","x":1677,"y":-547,"width":345,"height":293},
		{"id":"0151d8285f5b7901","type":"text","text":"兼顧 frequency 與 recency","x":-283,"y":548,"width":269,"height":58},
		{"id":"e243a02142f698b9","type":"text","text":"將 cache 分兩組，其中一組是只被 access 一次的；另外一組是被 access 超過一次的","x":-260,"y":324,"width":225,"height":179},
		{"id":"6c1c51b5e8407ff6","type":"text","text":"Tree PLRU","x":143,"y":335,"width":145,"height":54},
		{"id":"c3ef557e64f21c1a","type":"text","text":"Segmented LRU (SLRU)","x":-277,"y":181,"width":257,"height":58},
		{"id":"982632ce1fb55e58","type":"file","file":"img/data-structures-for-lfu-cache.png","x":1925,"y":313,"width":782,"height":440},
		{"id":"cc5d9c0f9ff7172a","type":"text","text":"適合存取行為具有循環性的情境","x":543,"y":-322,"width":304,"height":64},
		{"id":"ab0121db7a7fded0","type":"text","text":"可以更好的地方：\n\n- Fallback action in the `get` method when cache miss happens\n- Assure thread safety\n- Set TTL (time to live)\n","x":317,"y":2287,"width":540,"height":242},
		{"id":"79630be707ab58d6","type":"text","text":"Low Inter-reference Recency Set (LIRS)","x":737,"y":181,"width":222,"height":98},
		{"id":"efc9b444fe32d757","type":"text","text":"Adaptive Replacement Cache (ARC)","x":413,"y":181,"width":242,"height":100},
		{"id":"c5c5824916969474","type":"text","text":"#### MRU Cache","x":442,"y":-519,"width":185,"height":57,"color":"5"},
		{"id":"3e97c3b944d5e830","type":"text","text":"a → b → c → d → a → b → c → d → ...","x":588,"y":-183,"width":214,"height":96},
		{"id":"3872f18e9b59ba8e","type":"text","text":"most recently used","x":716,"y":-520,"width":211,"height":60},
		{"id":"e5fb45ad670a0614","type":"text","text":"least recently used","x":-277,"y":-382,"width":210,"height":60},
		{"id":"71fbe63774c2bfa9","type":"text","text":"#### LRU Cache","x":-542,"y":-380,"width":177,"height":56,"color":"5"},
		{"id":"a60e47b118e791bf","type":"text","text":"[Pseudo LRU (PLRU)](https://en.wikipedia.org/wiki/Pseudo-LRU)","x":95,"y":181,"width":242,"height":64},
		{"id":"924ef5f113840eeb","type":"text","text":"```Python\nfrom collections import OrderedDict, defaultdict\n\ntype primary = str | int | float | tuple[primary, ...]\n\nclass LFUNode:\n    def __init__(self, value) -> None:\n        self.value = value\n        self.frequency = 1\n\nclass LFUCache:\n    def __init__(self, capacity: int) -> None:\n        self.capacity = capacity\n        self._storage: dict[primary, LFUNode] = {}\n        self._freqency_map = defaultdict(OrderedDict)\n        self._min_frequency = 0\n\n    @property\n    def size(self) -> int:\n        return len(self._storage)\n\n    def get(self, key: primary):\n        if node := self._storage.get(key):\n            self.set(key, node.value)\n            return node.value\n        else:\n            raise KeyError\n\n    def set(self, key: primary, value) -> None:\n        if node := self._storage.get(key):\n            self._freqency_map[node.frequency].pop(key)\n            if (\n                self._min_frequency == node.frequency\n                and len(self._freqency_map[node.frequency]) == 0\n            ):\n                self._min_frequency += 1\n            node.frequency += 1\n            node.value = value\n            self._freqency_map[node.frequency][key] = node\n        else:\n            if self.size >= self.capacity:\n                key_removed, _ = self._freqency_map[self._min_frequency].popitem(\n                    last=False\n                )\n                del self._storage[key_removed]\n            self._storage[key] = self._freqency_map[1][key] = LFUNode(value)\n            self._min_frequency = 1\n```","x":982,"y":313,"width":821,"height":1132},
		{"id":"e2fd4ef3a4992525","type":"text","text":"多一個 hash map 紀錄「每個使用次數有哪些資料」（這些資料以 doubly-linked list 儲存）","x":1240,"y":-64,"width":304,"height":135},
		{"id":"dde35dc0834dc5db","type":"text","text":"- 缺點：removal 的 time complexity 較高（$O(\\log n)$）\n- 優點：較省 memory","x":55,"y":494,"width":321,"height":166}
	],
	"edges":[
		{"id":"ed24469fb7940a6f","fromNode":"ae2367a7bbcaafba","fromSide":"bottom","toNode":"e30480a497a782cb","toSide":"top"},
		{"id":"636fc09b16a95b24","fromNode":"71fbe63774c2bfa9","fromSide":"right","toNode":"e5fb45ad670a0614","toSide":"left"},
		{"id":"2236bdc83df279af","fromNode":"ae2367a7bbcaafba","fromSide":"right","toNode":"2de27ce6d945c0e2","toSide":"left"},
		{"id":"b8aa0dfa3b8fe157","fromNode":"ae2367a7bbcaafba","fromSide":"right","toNode":"46cc83bda5c9aaab","toSide":"left"},
		{"id":"368c9f37792529a0","fromNode":"c05fd1b6fec3d86e","fromSide":"left","toNode":"b9cf4e474ec87dde","toSide":"right"},
		{"id":"071fd0db56e9a091","fromNode":"9b41ba365c225fb7","fromSide":"bottom","toNode":"44d1fc4842b1ea2f","toSide":"top","label":"Python"},
		{"id":"e6b7fc0f699e6b0a","fromNode":"e2fd4ef3a4992525","fromSide":"bottom","toNode":"924ef5f113840eeb","toSide":"top","label":"Python"},
		{"id":"7be583003f8be875","fromNode":"9b41ba365c225fb7","fromSide":"left","toNode":"6b69ef02eb3c6368","toSide":"right"},
		{"id":"16587278fde98833","fromNode":"6b69ef02eb3c6368","fromSide":"left","toNode":"4f2ad4230ce2e802","toSide":"right"},
		{"id":"722f7d08f546ba94","fromNode":"ab0121db7a7fded0","fromSide":"bottom","toNode":"626cc11e548d08dd","toSide":"right"},
		{"id":"d908e912bcf787d8","fromNode":"71fbe63774c2bfa9","fromSide":"left","toNode":"10b247dec221b176","toSide":"right"},
		{"id":"4e47259e9a1e027e","fromNode":"ae2367a7bbcaafba","fromSide":"top","toNode":"cf1e23f2491f1a52","toSide":"bottom"},
		{"id":"2ed2ba7e15eae5ff","fromNode":"c05fd1b6fec3d86e","fromSide":"right","toNode":"0302a51d5d88567f","toSide":"left"},
		{"id":"39bdfc765684d83c","fromNode":"44d1fc4842b1ea2f","fromSide":"bottom","toNode":"80612e3000c36eba","toSide":"top","label":"改用 OrderedDict"},
		{"id":"6a3b0a4df3b11599","fromNode":"c3ef557e64f21c1a","fromSide":"bottom","toNode":"e243a02142f698b9","toSide":"top"},
		{"id":"b5fa913eada09191","fromNode":"e243a02142f698b9","fromSide":"bottom","toNode":"0151d8285f5b7901","toSide":"top"},
		{"id":"5a40f98e39aeca7d","fromNode":"d7f853006833e89a","fromSide":"bottom","toNode":"71fbe63774c2bfa9","toSide":"top"},
		{"id":"2484eef4309d41ee","fromNode":"d7f853006833e89a","fromSide":"bottom","toNode":"c5c5824916969474","toSide":"top"},
		{"id":"bd4fe2414483f85d","fromNode":"c5c5824916969474","fromSide":"right","toNode":"3872f18e9b59ba8e","toSide":"left"},
		{"id":"e6042256b6a4b58f","fromNode":"c5c5824916969474","fromSide":"bottom","toNode":"cc5d9c0f9ff7172a","toSide":"top"},
		{"id":"7244b22d0d282547","fromNode":"cc5d9c0f9ff7172a","fromSide":"bottom","toNode":"3e97c3b944d5e830","toSide":"top"},
		{"id":"65f60d14ff4cfa39","fromNode":"a60e47b118e791bf","fromSide":"bottom","toNode":"6c1c51b5e8407ff6","toSide":"top"},
		{"id":"5af6aaf2fc366643","fromNode":"6c1c51b5e8407ff6","fromSide":"bottom","toNode":"dde35dc0834dc5db","toSide":"top"},
		{"id":"e4597cb5a0e55ef9","fromNode":"924ef5f113840eeb","fromSide":"bottom","toNode":"ab0121db7a7fded0","toSide":"top"},
		{"id":"933fa5478385289a","fromNode":"fabe16447b626521","fromSide":"bottom","toNode":"c05fd1b6fec3d86e","toSide":"top"},
		{"id":"cb628ce15e08a2f0","fromNode":"80612e3000c36eba","fromSide":"right","toNode":"ab0121db7a7fded0","toSide":"top"},
		{"id":"9e0d52ca4a545d0f","fromNode":"c05fd1b6fec3d86e","fromSide":"right","toNode":"0b185278e27767dc","toSide":"left"},
		{"id":"4974f353b275cfee","fromNode":"80612e3000c36eba","fromSide":"bottom","toNode":"626cc11e548d08dd","toSide":"top"},
		{"id":"a485e9a4c662c0f5","fromNode":"71fbe63774c2bfa9","fromSide":"left","toNode":"8834d09658708173","toSide":"right"},
		{"id":"01df7b4ee36df411","fromNode":"9b41ba365c225fb7","fromSide":"bottom","toNode":"3cd4923f49b55a52","toSide":"top"},
		{"id":"bf624cf5b0b55fe5","fromNode":"e2fd4ef3a4992525","fromSide":"bottom","toNode":"982632ce1fb55e58","toSide":"top"},
		{"id":"b6adb93142c9b64d","fromNode":"71fbe63774c2bfa9","fromSide":"bottom","toNode":"1fb785f1e3df49dd","toSide":"top"},
		{"id":"1c22f7bde7b7016d","fromNode":"71fbe63774c2bfa9","fromSide":"bottom","toNode":"9b41ba365c225fb7","toSide":"top","label":"實作"},
		{"id":"01f19a3c2490a3c2","fromNode":"c5c5824916969474","fromSide":"bottom","toNode":"9b41ba365c225fb7","toSide":"right","label":"實作"},
		{"id":"0ce41df3bc959155","fromNode":"c05fd1b6fec3d86e","fromSide":"bottom","toNode":"e2fd4ef3a4992525","toSide":"top","label":"實作"},
		{"id":"9257ab5e596b6f5a","fromNode":"1ba328a217da69f0","fromSide":"bottom","toNode":"ae2367a7bbcaafba","toSide":"left"}
	]
}