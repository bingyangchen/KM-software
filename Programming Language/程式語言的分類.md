# 強型別 vs. 弱型別

### 強型別 (Strongly Typed)

不允許在賦予變數值時進行 "implicit conversion"，以 Python 為例：

```Python
x = 123 + "456"  # TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

### 弱型別 (Weakly Typed)

- 可以在賦予變數值時進行 "implicit conversion"，比如 JavaScript：

    ```JavaScript
    let x = 123 + "456";
    console.log(x)  // 123456
    console.log(typeof x)  // string
    ```

- 「比對」會分為「嚴格」與「寬鬆」兩種模式

    比如 JavaScript 的 `==`、`===` 與 `Object.is`（詳見 [Mozilla 官方文件](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Equality_comparisons_and_sameness)）

- 一個程式語言並非以二分法區分型別的強弱，而是一個光譜

    比如 Java 通常被認為是強型別語言，但其實在 Java 中很常使用以下方法將 `int` 轉為 `String`：

    ```Java
    int a = 1;
    String b = "" + a;
    ```

# 動態型別 vs. 靜態型別

### 動態型別 (Dynamic)

變數宣告後，可以改變型別。以 Python 為例：

```Python
x = 0
x = "A"
```

>[!Note]
>Python 雖然在 3.5 開始引入 [[Type Hints]]，但這並未改變它身為動態型別語言的事實。

### 靜態型別 (Static)

變數宣告後，不能改變其型別。以 TypeScript 為例：

```TypeScript
let x: number = 0;
x = "A";  // Type 'string' is not assignable to type 'number'.
```

![[strong-weak-dynamic-static.png]]

# 編譯式 vs. 直譯式

### 編譯式 (Compiled)

Compiler 將整包 **source code**（通常是[[Programming Language/零碎筆記#程式語言的演進|高階程式語言]]）編譯成與其語意等價的 [[machine code]] 後，只要 source code 沒有被更動，往後每次執行程式時，都是直接運行之前編譯好的 machine code，不須再次編譯。

### 直譯式 (Interpreted)

每執行到一個 [[Programming Language/零碎筆記#Expression vs. Statement|statement]]，理論上都要對該 statement 做解析，所以若某個 function 被呼叫了 n 次，function declaration 那段程式碼就會被解析 n 次，即使這 n 次根本就是在做一模一樣的事情。

然而現在的 interpreter 其實已經非常有效率了，在解析工作的眾多環節中，有些會被抽離出來，之所以抽離是因為那些環節可以只做一次（比如 type analysis，此處暫不展開）。

你或許常會看到把各種程式語言二分為 compiled language 與 interpreted language 的圖表或文章，但其實 ==interpreted language 也可能有 compilation phase（或者說通常都有）==；另外，interpreted language 也絕對==不是什麼事前工作都沒做就直接把 source code 一行接著一行執行==。上述兩個論點最明顯的證據就是大多數的程式語言都支援 function 的 [[Hoisting]]（可以先呼叫 function 再定義 function）。

# Class-based vs. Prototype-based

#TODO

參考資料｜<https://openhome.cc/Gossip/Programmer/ClassPrototypeBased.html>
